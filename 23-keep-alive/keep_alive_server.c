/**
 * TCP 有一个保持活跃的机制叫做 Keep-Alive 的机制，是这样规定的：
 *   定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，
 *   每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，
 *   则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。
 * 
 * 上述的可定义变量，分别被称为保活时间、保活时间间隔和保活探测次数。
 * 在 Linux 系统中，这些变量分别对应 sysctl 变量：
 * - net.ipv4.tcp_keepalive_time : 保活时间，默认是 7200 秒（2 小时）
 * - net.ipv4.tcp_keepalive_intvl: 保活时间间隔, 默认是 75 秒
 * - net.ipv4.tcp_keepalve_probes: 保活探测次数，默认是 9 次。
 * 
 * 具体的工作细节是：
 * - 第一种，对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，
 *          这样 TCP 保活时间会被重置，等待下一个 TCP 保活时间的到来。
 * - 第二种，对端程序崩溃并重启。当 TCP 保活的探测报文发送给对端后，对端是可以响应的，
 *          但由于没有该连接的有效信息，会产生一个 RST 报文，这样很快就会发现 TCP 连接已经被重置。
 * - 第三种，是对端程序崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，
 *          石沉大海，没有响应，连续几次，达到保活探测次数后，TCP 会报告该 TCP 连接已经死亡。
 * 
 * TCP 保活机制默认是关闭的，当我们选择打开时，可以分别在连接的两个方向上开启，也可以单独在一个方向上开启。
 * - 如果开启服务器端到客户端的检测，就可以在客户端非正常断连的情况下清除在服务器端保留的“脏数据”；
 * - 如果开启客户端到服务器端的检测，就可以在服务器无响应的情况下，重新发起连接。
 * 
 * 如果使用 TCP 自身的 keep-Alive 机制，在 Linux 系统中，最少需要经过 2 小时 11 分 15 秒才可以发现一个“死亡”连接。
 * 这个时间是怎么计算出来的呢？其实是通过 2 小时，加上 75 秒乘以 9 的总和。
 * 实际上，对很多对时延要求敏感的系统中，这个时间间隔是不可接受的。
 * 
 * 所以，一般的做法是通过在应用程序中模拟 TCP Keep-Alive 机制，来完成在应用层的连接探活。
 * 我们可以设计一个 PING-PONG 的机制，需要保活的一方，比如客户端，在保活时间达到后，发起对连接的 PING 操作，
 * 如果服务器端对 PING 操作有回应，则重新设置保活时间，否则对探测次数进行计数，
 * 如果最终探测次数达到了保活探测次数预先设置的值之后，则认为连接已经无效。
*/